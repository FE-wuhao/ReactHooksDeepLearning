1. 一个组件文件(组件名.tsx)中可以包含不止一个**fucntion**，所以对于不依赖于组件内部任何值的函数可以提取到组件函数外面，需要的时候直接调用即可。

2. 论**useMemo**和**useCallback**各自的作用：

   * **useMemo**通常用于缓存函数的返回值，在依赖未发生变化的情况下不重新执行函数而直接返回之前函数执行的结果
   * **useCallback**通常用于保证从父组件传入子组件的函数，在依赖未发生变化的情况下，传入相同的函数到子组件，从而避免子组件不必要的重新渲染。
3. **useCallback**的使用场景：

   * 父组件向子组件传递的函数，通过**useCallback**缓存
   * 一个组件如果有**useEffect**的依赖是组件内的函数，那么就不希望每次重新渲染后都生成一个新的函数，从而导致**useEffect**的非预期执行增加开销。也可以通过**useCallback**添加一个依赖，判断渲染前后依赖是否发生变化，没有变化就不创建新函数，从而减少性能浪费。
   * [**资料链接**](https://blog.csdn.net/sinat_17775997/article/details/94453167)

4. **useState**、**useEffect**、**useMemo**、**useCallback**都用到了闭包，所以他们访问到的都只是当前渲染帧的数据，因为他们在每一个新的渲染帧中都会创建新的自己，想要追溯之前渲染帧中的数据，需要事先用**useRef**保存好，并且不再去改变它，这样在你想要的任意时刻都可以获取到过去的某一帧的值。

5. 函数的副作用：所谓的副作用，就是除了返回一个值外还对主函数产生了其他影响，比如说改变了主函数中定义的其他变量的值，因此就有了**纯函数**和**非纯函数**的说法了，所谓的函数式编程也就是不允许产生副作用，也就是无副作用编程。useEffect可以处理副作用，但是**useCallback**和**useMeomo**不可以。

   [资料链接](http://www.fly63.com/article/detial/1176)

6. 

